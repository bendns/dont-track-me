//! HTML audit report generator â€” Primer-inspired design, multi-page SPA.
//!
//! Generates a self-contained single HTML file with embedded CSS and JavaScript.
//! Features light/dark mode, responsive grid layout, and print support.

use chrono::Utc;

use crate::models::{AuditResult, Finding, ThreatLevel};
use crate::scoring::get_score_tier;

/// Primer-inspired score colors.
fn score_color(score: u32) -> &'static str {
    match get_score_tier(score).label {
        "Excellent" => "#1a7f37",
        "Good" => "#0969da",
        "Moderate" => "#9a6700",
        "Poor" | "Critical" => "#cf222e",
        _ => "#656d76",
    }
}

/// Threat level badge colors (bg, fg, border).
fn threat_colors(level: &ThreatLevel) -> (&'static str, &'static str, &'static str) {
    match level {
        ThreatLevel::Critical => ("#ffebe9", "#cf222e", "#cf222e"),
        ThreatLevel::High => ("#ffebe9", "#cf222e", "#ffcecb"),
        ThreatLevel::Medium => ("#fff8c5", "#9a6700", "#efd97a"),
        ThreatLevel::Low => ("#ddf4ff", "#0969da", "#b6d9fc"),
        ThreatLevel::Info => ("#f6f8fa", "#656d76", "#d0d7de"),
    }
}

/// HTML-escape user-provided text.
fn esc(text: &str) -> String {
    text.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
}

/// Derive a safe HTML id from a module name.
fn module_id(name: &str) -> String {
    let safe: String = name
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '-' {
                c
            } else {
                '-'
            }
        })
        .collect();
    format!("mod-{safe}")
}

/// Render a severity badge.
fn render_badge(level: &ThreatLevel) -> String {
    let (bg, fg, border) = threat_colors(level);
    format!(
        r#"<span class="badge" style="background:{bg};color:{fg};border-color:{border}">{}</span>"#,
        esc(level.as_str()).to_uppercase()
    )
}

/// Render a single finding.
fn render_finding(finding: &Finding) -> String {
    format!(
        r#"<div class="finding">
<div class="finding-header">{}<span class="finding-title">{}</span></div>
<div class="finding-desc">{}</div>
<div class="finding-remediation"><strong>Remediation:</strong> {}</div>
</div>"#,
        render_badge(&finding.threat_level),
        esc(&finding.title),
        esc(&finding.description),
        esc(&finding.remediation),
    )
}

/// Render a clickable grid card for a module.
fn render_grid_card(result: &AuditResult) -> String {
    let color = score_color(result.score);
    let label = get_score_tier(result.score).label;
    let mid = module_id(&result.module_name);
    format!(
        r#"<div class="grid-card" onclick="showPage('{mid}')">
<div class="module-name">{name}</div>
<div class="score-text" style="color:{color}">{score}/100</div>
<div class="score-sublabel">{label}</div>
<div class="progress-bar"><div class="progress-fill" style="width:{score}%;background:{color}"></div></div>
</div>"#,
        name = esc(&result.module_name),
        score = result.score,
    )
}

/// Render a detail page for a single module.
fn render_module_page(result: &AuditResult) -> String {
    let color = score_color(result.score);
    let label = get_score_tier(result.score).label;
    let mid = module_id(&result.module_name);

    let findings_html = if result.findings.is_empty() {
        r#"<div class="no-findings">No issues found.</div>"#.to_string()
    } else {
        result
            .findings
            .iter()
            .map(render_finding)
            .collect::<Vec<_>>()
            .join("\n")
    };

    let count = result.findings.len();
    let count_text = if count == 0 {
        "No issues".to_string()
    } else {
        format!("{count} finding{}", if count != 1 { "s" } else { "" })
    };

    format!(
        r#"<div class="page" id="{mid}">
<div class="container">
<a class="back-link" onclick="showPage('overview')">&larr; Back to overview</a>
<div class="module-header">
<div class="module-score-ring" style="border-color:{color};color:{color}">{score}</div>
<div class="module-info">
<h2>{name}</h2>
<div class="module-sublabel">{label} &middot; {count_text}</div>
</div>
</div>
<div class="card">{findings_html}</div>
<footer>Generated by dont-track-me &middot; {name}</footer>
</div>
</div>"#,
        score = result.score,
        name = esc(&result.module_name),
    )
}

/// Generate a self-contained HTML audit report.
///
/// The report is a single-page application with an overview showing all module
/// scores in a grid, and a detail page for each module accessible by clicking.
pub fn generate_html_report(results: &[AuditResult], overall_score: f64) -> String {
    let score_u32 = overall_score.round() as u32;
    let color = score_color(score_u32);
    let label = get_score_tier(score_u32).label;
    let now = Utc::now().format("%Y-%m-%d %H:%M UTC").to_string();

    // Sort results by score (worst first)
    let mut sorted: Vec<&AuditResult> = results.iter().collect();
    sorted.sort_by_key(|r| r.score);

    let grid_cards: String = sorted.iter().map(|r| render_grid_card(r)).collect();
    let module_pages: String = sorted.iter().map(|r| render_module_page(r)).collect();

    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Privacy Audit Report</title>
<style>{CSS}</style>
</head>
<body>
<div class="page active" id="overview">
<div class="container">
<header>
<h1>Privacy Audit Report</h1>
<div class="subtitle">{now}</div>
<div class="score-ring" style="border-color:{color};color:{color}">{score}</div>
<div class="score-label" style="color:{color}">{label}</div>
</header>
<div class="grid">{grid_cards}</div>
<footer>Generated by dont-track-me &middot; {now}</footer>
</div>
</div>
{module_pages}
<script>{JS}</script>
</body>
</html>"#,
        now = esc(&now),
        score = score_u32,
    )
}

const JS: &str = r#"
function showPage(id) {
  document.querySelectorAll('.page').forEach(function(p) {
    p.classList.remove('active');
  });
  document.getElementById(id).classList.add('active');
  window.scrollTo(0, 0);
}
"#;

const CSS: &str = r#"
:root {
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: #d8dee4;
  --color-fg-default: #1f2328;
  --color-fg-muted: #656d76;
  --color-success: #1a7f37;
  --color-danger: #cf222e;
  --color-attention: #9a6700;
  --color-accent: #0969da;
}

@media (prefers-color-scheme: dark) {
  :root {
    --color-canvas-default: #161b22;
    --color-canvas-subtle: #0d1117;
    --color-border-default: #30363d;
    --color-border-muted: #21262d;
    --color-fg-default: #e6edf3;
    --color-fg-muted: #8b949e;
    --color-success: #3fb950;
    --color-danger: #f85149;
    --color-attention: #d29922;
    --color-accent: #58a6ff;
  }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans",
    Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
  font-size: 14px;
  line-height: 1.5;
  color: var(--color-fg-default);
  background: var(--color-canvas-subtle);
  padding: 32px 16px;
}

.container { max-width: 960px; margin: 0 auto; }

header { text-align: center; margin-bottom: 32px; }
header h1 { font-size: 24px; font-weight: 600; margin-bottom: 8px; }
header .subtitle { color: var(--color-fg-muted); font-size: 14px; }

.score-ring {
  display: inline-flex; align-items: center; justify-content: center;
  width: 96px; height: 96px; border-radius: 50%; border: 4px solid;
  margin: 16px 0 8px; font-size: 28px; font-weight: 700;
}

.score-label { font-size: 16px; font-weight: 600; margin-bottom: 16px; }

.card {
  background: var(--color-canvas-default); border: 1px solid var(--color-border-default);
  border-radius: 6px; margin-bottom: 16px; overflow: hidden;
}

.card-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 12px 16px; border-bottom: 1px solid var(--color-border-muted);
  background: var(--color-canvas-subtle);
}

.card-header h2 { font-size: 16px; font-weight: 600; }

.score-badge {
  display: inline-block; padding: 2px 10px; border-radius: 24px;
  font-size: 12px; font-weight: 600; color: #ffffff;
}

.grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 12px; margin-bottom: 32px;
}

.grid-card {
  background: var(--color-canvas-default); border: 1px solid var(--color-border-default);
  border-radius: 6px; padding: 16px; cursor: pointer;
  transition: border-color 0.15s, box-shadow 0.15s;
}

.grid-card:hover {
  border-color: var(--color-accent);
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}

.grid-card .module-name { font-weight: 600; font-size: 14px; margin-bottom: 8px; }
.grid-card .score-text { font-size: 20px; font-weight: 700; margin-bottom: 4px; }
.grid-card .score-sublabel { font-size: 12px; color: var(--color-fg-muted); }

.progress-bar {
  height: 8px; background: var(--color-border-muted);
  border-radius: 4px; overflow: hidden; margin-top: 8px;
}

.progress-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }

.finding { padding: 12px 16px; border-bottom: 1px solid var(--color-border-muted); }
.finding:last-child { border-bottom: none; }
.finding-header { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }

.badge {
  display: inline-block; padding: 1px 8px; border-radius: 24px;
  font-size: 11px; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.02em; border: 1px solid; white-space: nowrap;
}

.finding-title { font-weight: 600; font-size: 14px; }
.finding-desc { color: var(--color-fg-muted); font-size: 13px; margin: 4px 0; }

.finding-remediation {
  font-size: 13px; margin-top: 8px; padding: 8px 12px;
  background: var(--color-canvas-subtle);
  border-left: 3px solid var(--color-accent);
  border-radius: 0 4px 4px 0; color: var(--color-fg-default);
}

.finding-remediation strong { color: var(--color-accent); font-weight: 600; }
.no-findings { padding: 16px; color: var(--color-success); font-size: 14px; }

footer {
  text-align: center; color: var(--color-fg-muted); font-size: 12px;
  margin-top: 32px; padding-top: 16px;
  border-top: 1px solid var(--color-border-default);
}

.page { display: none; }
.page.active { display: block; }

.back-link {
  display: inline-flex; align-items: center; gap: 4px;
  color: var(--color-accent); cursor: pointer; font-size: 14px;
  font-weight: 500; margin-bottom: 16px; text-decoration: none;
}

.back-link:hover { text-decoration: underline; }

.module-header { display: flex; align-items: center; gap: 16px; margin-bottom: 24px; }

.module-header .module-score-ring {
  display: inline-flex; align-items: center; justify-content: center;
  width: 64px; height: 64px; border-radius: 50%; border: 3px solid;
  font-size: 20px; font-weight: 700; flex-shrink: 0;
}

.module-header .module-info h2 { font-size: 20px; font-weight: 600; }
.module-header .module-info .module-sublabel { color: var(--color-fg-muted); font-size: 13px; }
.findings-count { color: var(--color-fg-muted); font-size: 13px; margin-bottom: 12px; }

@media print {
  body { background: #fff; padding: 0; }
  .card, .grid-card { break-inside: avoid; }
  .score-ring { border-width: 3px; }
  .page { display: block !important; page-break-before: always; }
  .page:first-child { page-break-before: avoid; }
  .back-link { display: none; }
}

@media (max-width: 640px) {
  .grid { grid-template-columns: 1fr; }
  header h1 { font-size: 20px; }
  .score-ring { width: 72px; height: 72px; font-size: 22px; }
}
"#;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Finding;

    fn make_finding(title: &str, level: ThreatLevel) -> Finding {
        Finding {
            title: title.to_string(),
            description: "Test description".to_string(),
            threat_level: level,
            remediation: "Test remediation".to_string(),
        }
    }

    fn make_result(name: &str, score: u32, findings: Vec<Finding>) -> AuditResult {
        AuditResult {
            module_name: name.to_string(),
            score,
            findings,
            raw_data: std::collections::HashMap::new(),
        }
    }

    #[test]
    fn html_escape_special_chars() {
        assert_eq!(
            esc("<script>alert('xss')"),
            "&lt;script&gt;alert(&#x27;xss&#x27;)"
        );
        assert_eq!(esc("a & b"), "a &amp; b");
        assert_eq!(esc("\"quoted\""), "&quot;quoted&quot;");
    }

    #[test]
    fn module_id_is_safe() {
        assert_eq!(module_id("cookies"), "mod-cookies");
        assert_eq!(module_id("search_noise"), "mod-search-noise");
        assert_eq!(module_id("app-scanner"), "mod-app-scanner");
    }

    #[test]
    fn score_color_returns_correct_hex() {
        assert_eq!(score_color(95), "#1a7f37"); // Excellent -> green
        assert_eq!(score_color(75), "#0969da"); // Good -> blue
        assert_eq!(score_color(55), "#9a6700"); // Moderate -> orange
        assert_eq!(score_color(25), "#cf222e"); // Critical -> red
    }

    #[test]
    fn generate_report_contains_essential_elements() {
        let results = vec![
            AuditResult {
                module_name: "dns".to_string(),
                score: 85,
                findings: vec![Finding {
                    title: "DNS over HTTPS not configured".to_string(),
                    description: "Your DNS queries are sent in plaintext.".to_string(),
                    threat_level: ThreatLevel::Medium,
                    remediation: "Enable DNS over HTTPS.".to_string(),
                }],
                raw_data: std::collections::HashMap::new(),
            },
            AuditResult {
                module_name: "cookies".to_string(),
                score: 60,
                findings: vec![],
                raw_data: std::collections::HashMap::new(),
            },
        ];

        let html = generate_html_report(&results, 72.5);

        assert!(html.contains("<!DOCTYPE html>"));
        assert!(html.contains("Privacy Audit Report"));
        assert!(html.contains("73")); // rounded overall score
        assert!(html.contains("mod-dns"));
        assert!(html.contains("mod-cookies"));
        assert!(html.contains("DNS over HTTPS not configured"));
        assert!(html.contains("No issues found."));
        assert!(html.contains("showPage"));
        assert!(html.contains("prefers-color-scheme: dark"));
    }

    #[test]
    fn report_escapes_user_content() {
        let results = vec![AuditResult {
            module_name: "test".to_string(),
            score: 50,
            findings: vec![Finding {
                title: "XSS <script>alert(1)</script>".to_string(),
                description: "Desc with \"quotes\" & <tags>".to_string(),
                threat_level: ThreatLevel::High,
                remediation: "Fix it".to_string(),
            }],
            raw_data: std::collections::HashMap::new(),
        }];

        let html = generate_html_report(&results, 50.0);

        assert!(!html.contains("<script>alert(1)</script>"));
        assert!(html.contains("&lt;script&gt;"));
        assert!(html.contains("&amp;"));
    }

    #[test]
    fn report_sorts_by_score_worst_first() {
        let results = vec![
            AuditResult {
                module_name: "good".to_string(),
                score: 90,
                findings: vec![],
                raw_data: std::collections::HashMap::new(),
            },
            AuditResult {
                module_name: "bad".to_string(),
                score: 30,
                findings: vec![],
                raw_data: std::collections::HashMap::new(),
            },
        ];

        let html = generate_html_report(&results, 60.0);

        let bad_pos = html.find("mod-bad").unwrap();
        let good_pos = html.find("mod-good").unwrap();
        assert!(bad_pos < good_pos, "Worst scores should appear first");
    }

    // --- Ported from Python test_report.py ---

    #[test]
    fn report_has_doctype() {
        let html = generate_html_report(&[], 0.0);
        assert!(html.starts_with("<!DOCTYPE html>"));
    }

    #[test]
    fn report_has_viewport_meta() {
        let html = generate_html_report(&[], 50.0);
        assert!(html.contains(r#"name="viewport""#));
    }

    #[test]
    fn report_has_dark_mode_media_query() {
        let html = generate_html_report(&[], 50.0);
        assert!(html.contains("prefers-color-scheme: dark"));
    }

    #[test]
    fn report_has_print_css() {
        let html = generate_html_report(&[], 50.0);
        assert!(html.contains("@media print"));
    }

    #[test]
    fn report_has_javascript() {
        let html = generate_html_report(&[], 50.0);
        assert!(html.contains("showPage"));
    }

    #[test]
    fn report_overview_shows_overall_score() {
        let html = generate_html_report(&[], 82.0);
        // The overall score is rendered inside a score-ring element
        assert!(html.contains("score-ring"));
        assert!(html.contains(">82<"));
    }

    #[test]
    fn report_overview_shows_timestamp() {
        let html = generate_html_report(&[], 50.0);
        assert!(html.contains("UTC"));
    }

    #[test]
    fn report_overview_shows_module_grid() {
        let results = vec![make_result("test", 50, vec![])];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains(r#"class="grid""#));
    }

    #[test]
    fn report_grid_cards_are_clickable() {
        let results = vec![make_result("test", 50, vec![])];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains("onclick=\"showPage"));
    }

    #[test]
    fn report_module_pages_have_back_link() {
        let results = vec![make_result("test", 50, vec![])];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains("Back to overview"));
    }

    #[test]
    fn report_module_page_shows_score() {
        let results = vec![make_result("test", 73, vec![])];
        let html = generate_html_report(&results, 73.0);
        // The module detail page renders the score in a module-score-ring
        assert!(html.contains("module-score-ring"));
        assert!(html.contains(">73<"));
    }

    #[test]
    fn report_module_page_shows_findings() {
        let results = vec![make_result(
            "test",
            50,
            vec![make_finding("Leak found", ThreatLevel::High)],
        )];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains(r#"class="finding""#));
    }

    #[test]
    fn report_finding_has_description() {
        let results = vec![make_result(
            "test",
            50,
            vec![make_finding("Leak", ThreatLevel::Medium)],
        )];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains("finding-desc"));
    }

    #[test]
    fn report_finding_has_remediation() {
        let results = vec![make_result(
            "test",
            50,
            vec![make_finding("Leak", ThreatLevel::Medium)],
        )];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains("finding-remediation"));
    }

    #[test]
    fn report_critical_badge() {
        let results = vec![make_result(
            "test",
            20,
            vec![make_finding("Crit", ThreatLevel::Critical)],
        )];
        let html = generate_html_report(&results, 20.0);
        assert!(html.contains("CRITICAL"));
    }

    #[test]
    fn report_high_badge() {
        let results = vec![make_result(
            "test",
            40,
            vec![make_finding("Hi", ThreatLevel::High)],
        )];
        let html = generate_html_report(&results, 40.0);
        assert!(html.contains("HIGH"));
    }

    #[test]
    fn report_medium_badge() {
        let results = vec![make_result(
            "test",
            60,
            vec![make_finding("Med", ThreatLevel::Medium)],
        )];
        let html = generate_html_report(&results, 60.0);
        assert!(html.contains("MEDIUM"));
    }

    #[test]
    fn report_low_badge() {
        let results = vec![make_result(
            "test",
            80,
            vec![make_finding("Lo", ThreatLevel::Low)],
        )];
        let html = generate_html_report(&results, 80.0);
        assert!(html.contains("LOW"));
    }

    #[test]
    fn report_info_badge() {
        let results = vec![make_result(
            "test",
            90,
            vec![make_finding("Inf", ThreatLevel::Info)],
        )];
        let html = generate_html_report(&results, 90.0);
        assert!(html.contains("INFO"));
    }

    #[test]
    fn report_badge_colors_critical() {
        let badge = render_badge(&ThreatLevel::Critical);
        assert!(badge.contains("#cf222e"));
    }

    #[test]
    fn report_badge_colors_info() {
        let badge = render_badge(&ThreatLevel::Info);
        assert!(badge.contains("#656d76"));
    }

    #[test]
    fn report_score_excellent_color() {
        assert_eq!(score_color(95), "#1a7f37");
    }

    #[test]
    fn report_score_poor_color() {
        assert_eq!(score_color(35), "#cf222e");
    }

    #[test]
    fn report_score_moderate_color() {
        assert_eq!(score_color(55), "#9a6700");
    }

    #[test]
    fn report_empty_results() {
        let html = generate_html_report(&[], 0.0);
        assert!(html.contains("<!DOCTYPE html>"));
        assert!(html.contains("</html>"));
    }

    #[test]
    fn report_single_module_no_findings() {
        let results = vec![make_result("clean", 100, vec![])];
        let html = generate_html_report(&results, 100.0);
        assert!(html.contains("No issues found."));
    }

    #[test]
    fn report_multiple_modules_sorted() {
        let results = vec![
            make_result("alpha", 90, vec![]),
            make_result("beta", 30, vec![]),
            make_result("gamma", 60, vec![]),
        ];
        let html = generate_html_report(&results, 60.0);
        let pos_beta = html.find("mod-beta").unwrap();
        let pos_gamma = html.find("mod-gamma").unwrap();
        let pos_alpha = html.find("mod-alpha").unwrap();
        assert!(
            pos_beta < pos_gamma && pos_gamma < pos_alpha,
            "Modules should be sorted by score ascending (worst first)"
        );
    }

    #[test]
    fn report_special_chars_in_module_name() {
        let results = vec![make_result("<script>&\"test", 50, vec![])];
        let html = generate_html_report(&results, 50.0);
        assert!(!html.contains("<script>&\"test"));
        assert!(html.contains("&lt;script&gt;&amp;&quot;test"));
    }

    #[test]
    fn report_special_chars_in_finding_title() {
        let finding = Finding {
            title: "<b>bold</b> & \"quoted\"".to_string(),
            description: "desc".to_string(),
            threat_level: ThreatLevel::Medium,
            remediation: "fix".to_string(),
        };
        let results = vec![make_result("test", 50, vec![finding])];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains("&lt;b&gt;bold&lt;/b&gt; &amp; &quot;quoted&quot;"));
    }

    #[test]
    fn report_special_chars_in_description() {
        let finding = Finding {
            title: "title".to_string(),
            description: "a < b & c > d".to_string(),
            threat_level: ThreatLevel::Low,
            remediation: "fix".to_string(),
        };
        let results = vec![make_result("test", 50, vec![finding])];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains("a &lt; b &amp; c &gt; d"));
    }

    #[test]
    fn report_special_chars_in_remediation() {
        let finding = Finding {
            title: "title".to_string(),
            description: "desc".to_string(),
            threat_level: ThreatLevel::Low,
            remediation: "use <code> & \"quotes\"".to_string(),
        };
        let results = vec![make_result("test", 50, vec![finding])];
        let html = generate_html_report(&results, 50.0);
        assert!(html.contains("use &lt;code&gt; &amp; &quot;quotes&quot;"));
    }

    #[test]
    fn report_overall_score_rounding() {
        let html = generate_html_report(&[], 72.5);
        // 72.5 rounds to 73
        assert!(html.contains(">73<"));
    }

    #[test]
    fn report_score_zero() {
        let html = generate_html_report(&[], 0.0);
        assert!(html.contains(">0<"));
    }

    #[test]
    fn report_score_hundred() {
        let html = generate_html_report(&[], 100.0);
        assert!(html.contains(">100<"));
    }

    #[test]
    fn report_many_findings() {
        let findings: Vec<Finding> = (0..12)
            .map(|i| make_finding(&format!("Finding {i}"), ThreatLevel::Medium))
            .collect();
        let results = vec![make_result("test", 30, findings)];
        let html = generate_html_report(&results, 30.0);
        for i in 0..12 {
            assert!(
                html.contains(&format!("Finding {i}")),
                "Missing Finding {i}"
            );
        }
    }

    #[test]
    fn report_finding_count_singular() {
        let results = vec![make_result(
            "test",
            80,
            vec![make_finding("One issue", ThreatLevel::Low)],
        )];
        let html = generate_html_report(&results, 80.0);
        assert!(html.contains("1 finding"));
        // Must NOT contain "1 findings"
        assert!(!html.contains("1 findings"));
    }

    #[test]
    fn report_finding_count_plural() {
        let findings = vec![
            make_finding("A", ThreatLevel::Low),
            make_finding("B", ThreatLevel::Low),
            make_finding("C", ThreatLevel::Low),
        ];
        let results = vec![make_result("test", 70, findings)];
        let html = generate_html_report(&results, 70.0);
        assert!(html.contains("3 findings"));
    }

    #[test]
    fn report_progress_bar_width() {
        let results = vec![make_result("test", 42, vec![])];
        let html = generate_html_report(&results, 42.0);
        assert!(html.contains("width:42%"));
    }

    #[test]
    fn module_id_with_spaces() {
        assert_eq!(module_id("my module"), "mod-my-module");
    }

    #[test]
    fn module_id_with_underscores() {
        assert_eq!(module_id("my_module"), "mod-my-module");
    }

    #[test]
    fn esc_empty_string() {
        assert_eq!(esc(""), "");
    }

    #[test]
    fn esc_no_special_chars() {
        assert_eq!(esc("hello world 123"), "hello world 123");
    }

    #[test]
    fn threat_colors_returns_three_tuple() {
        let levels = [
            ThreatLevel::Critical,
            ThreatLevel::High,
            ThreatLevel::Medium,
            ThreatLevel::Low,
            ThreatLevel::Info,
        ];
        for level in &levels {
            let (bg, fg, border) = threat_colors(level);
            assert!(!bg.is_empty(), "bg empty for {level:?}");
            assert!(!fg.is_empty(), "fg empty for {level:?}");
            assert!(!border.is_empty(), "border empty for {level:?}");
        }
    }

    #[test]
    fn render_badge_uppercase() {
        let badge = render_badge(&ThreatLevel::Medium);
        assert!(badge.contains("MEDIUM"));
        let badge = render_badge(&ThreatLevel::Critical);
        assert!(badge.contains("CRITICAL"));
        let badge = render_badge(&ThreatLevel::Info);
        assert!(badge.contains("INFO"));
    }
}
